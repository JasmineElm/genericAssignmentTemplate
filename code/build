#!/usr/bin/env bash

######  STRICT MODE  ###########################################

# set -u
# set -e
# trap 'echo "Aborting due to errexit on line $LINENO. Exit code: $?" >&2' ERR
# set -o errtrace
# set -o pipefail
# IFS=$'\n\t'

######  VARIABLES    ###########################################

_ME="$(basename "${0}")"

######  FUNCTIONS    ###########################################

# Filename.  
# We assume that the parent dir is relevant e.g.
# parent dir = "Book"
# child dir = "Chapter"
# Filename = "Book_-_Chapter"

_fpathToFN() {
  DIRNAME=$(pwd)
  base1="${DIRNAME##*/}"
  dir1="${DIRNAME%/*}"
  echo "${dir1##*/} - $base1"| sed 's/ /_/g'
}

### Work out input and output files
# if just one md file use that, otherwise cat all
# md files into a temp file that we'll delete later...


function _rndFN {
    # stolen from https://stackoverflow.com/questions/32484504/using-random-to-generate-a-random-string-in-bash
    local DEFAULT_LENGTH=64
    local LENGTH=${1:-$DEFAULT_LENGTH}
    tr -dc A-Za-z0-9 </dev/urandom | head -c "$LENGTH"
}

_tmpFileName() {
    tmp=$(_rndFN)
    ## we don't want to overwrite an existing file...
    while [ -f "$tmp" ]
      do   tmp=$(_rndFN 8)
    done
    printf "%s$tmp"
}

_inputName() {
    count=$(find . -type f -iname "*.md" 2>/dev/null | wc -l)
    if [ "$count" = 1 ]
    then 
      input=$(find . -type f -iname "*.md")
    else
      tmp=$(_tmpFileName)
      cat $(find . -iname "*.md" -exec echo "{}" \; | sort) >>"$tmp.tmp"
      input="$tmp.tmp"
    fi
   printf "%s$input" 
}

_catInput() {
  true
}

_outputName() {
     count=$(find . -type f -iname "*.md" 2>/dev/null | wc -l)
    if [ "$count" = 1 ]
    then
      input=$(find . -type f -iname "*.md")
      output=$(basename -- "$input")
      output=output/"${output%.*}"
    else
      output="output/$(_fpathToFN)"
    fi
   printf "%s$output" 


}
### BUILD ARGUMENTS ###
#
# some tex templates override the language param
# declare here not in the meta.yaml to be safe

_buildPDF() {
  input=$(_inputName)
  output=$(_outputName)
  logfile=$output.pdf.log
  printf "%sbuilding pdf...\\n  See $logfile for details\\n"
  pandoc  "$input"              \
    --metadata-file=meta.yaml   \
    -V lang=en-GB               \
    --biblio=references.bib     \
    --verbose                   \
		--pdf-engine=xelatex        \
		--output="$output".pdf      \
		--template template/def.tex \
		--highlight-style=zenburn   \
    --strip-comments            \
    --csl=template/def.csl > "$logfile" 2>&1
  }

_buildDocx() {
  input=$(_inputName)
  output=$(_outputName)
  logfile=$output.docx.log
  printf "%sbuilding word document...\\n  See $logfile for details\\n"
  pandoc  "$input"               \
		--biblio=references.bib      \
    --verbose                    \
		-o "$output".docx            \
		--template template/def.docx \
		--highlight-style=zenburn    \
    --strip-comments             \
		--csl=template/def.csl > "$logfile" 2>&1
}

_clean() {
       [ "$(ls -A output)" ] &&
       [ "$(ls -A output)" ] &&
     rm -v output/* || printf "Already empty: nothing to do\n"
}

_tidy() {
  # if we used a temp file, remove it.
  find . -type f -iname "*.tmp" -delete 
}

_print_help() {
  cat <<HEREDOC
Simplifies building pdf / word documents 

Usage:
  ${_ME} [cpwh]

Options:
  -h    Show this screen.
  -c    clear the output directory
  -p    build pdf
  -w    build word

HEREDOC
}

######  MAIN         ###########################################  

_main() {
    if [[ -z "$*" ]]
        then 
          _buildPDF
    fi
    while getopts ":cpwh" opt; do
        case $opt in
            \?)
            echo "Invalid option: -$OPTARG" >&2
            return
            ;;
            c)
            _clean
            return
            ;;
            p)
            _buildPDF
            ;;
            w)
            _buildDocx
            ;;
            h)
            _print_help
            return
            ;;
        esac
    done
    _tidy
}
_main "$@"
